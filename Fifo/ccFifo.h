#pragma once

/*==============================================================================

Fifo memory class template. 

It is not thread safe.
It is not shared memory safe.

==============================================================================*/
//******************************************************************************
//******************************************************************************
//******************************************************************************

//******************************************************************************
//******************************************************************************
//******************************************************************************

namespace CC
{

//******************************************************************************
//******************************************************************************
//******************************************************************************

template <class Element,int Size>
class Fifo
{
public:

   //***************************************************************************
   //***************************************************************************
   //***************************************************************************
   // Members.

   // Element index of the next element to put to.
   int mPutIndex;

   // Number of put operations that have been executed.
   int mPutCount;

   // If true then the queue is full and get operations can commence.
   bool mFullFlag;

   // Array of elements.
   Element mElement[Size];

   //***************************************************************************
   //***************************************************************************
   //***************************************************************************
   // Methods.

   // Constructor.
   Fifo()
   {
      reset();
   }

   void reset()
   {
      mPutIndex = 0;
      mPutCount = 0;
      mFullFlag = false;
   }

   //***************************************************************************
   //***************************************************************************
   //***************************************************************************
   // This writes an element to the queue.

   bool doPut (Element& aElement)
   {
      // Copy the source element into the element at the queue put index.
      mElement[mPutIndex] = aElement;

      // Advance the put index.
      ++mPutIndex %= Size;

      // Advance the put count and set the valid flag.
      mFullFlag = ++mPutCount >= Size;
      return mFullFlag;
   }

   //***************************************************************************
   //***************************************************************************
   //***************************************************************************
   // This reads an element from the tail.
   
   Element& doGet()
   {
      // Calculate the get index.
      int tGetIndex = (mPutIndex + Size) % Size;

      // Return the element at the get index.
      return mElement[tGetIndex];
   }

   //***************************************************************************
   //***************************************************************************
   //***************************************************************************
   // This reads an element from the tail.

   Element& elementAt(int aGetIndex)
   {
      // Calculate the get index.
      int tGetIndex = (mPutIndex + aGetIndex) % Size;

      // Return the element at the get index.
      return mElement[tGetIndex];
   }
};

//******************************************************************************
//******************************************************************************
//******************************************************************************
}//namespace

#if 0

Z^-3   Z^-2  Z^-1  1
k-3    k-2   k-1   k

0      1     2     3

#endif